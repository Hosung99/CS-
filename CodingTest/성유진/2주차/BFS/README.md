## [그림](https://www.acmicpc.net/problem/1926)
### 문제 풀이 방식
0~n-1, 0~m-1 중에 방문하지 않았고, 그림에 해당하는 board[i][j]가 1인 경우를 시작점으로 선정하여 bfs를 수행하였습니다.  
그리고 bfs를 수행하는 경우는 하나의 그림에 해당하기 때문에 그림개수를 하나씩 증가 시켜주었습니다.

bfs함수에서는 현재 위치에서 네 방향을 확인하여 방문하지 않았고 board값이 1인 경우에 방문하도록 하였습니다.  
그림의 크기는 큐에서 새로운 원소를 빼낼 때마다 하나씩 키워주고, bfs 방문이 모두 끝난 경우에 반환하도록 하였습니다.  

### java에서 pair 사용
java에는 pair가 없어서 큐에 원소의 위치 {i, j}를 배열로 넣어주었습니다.

```java
Queue<int[]> Q = new LinkedList<>();
// 원소 삽입
Q.offer(new int[]{ni, nj});

// 원소 제거
int[] cur = Q.poll();
int curi = cur[0];
int curj = cur[1];
```

## [빙산](https://www.acmicpc.net/problem/2573)
### 문제 풀이 방식
얼음 칸 (0이 아닌 칸)의 수(`countTotalIce`)와 0이 아닌 칸에서 bfs를 진행하여 방문한 칸의 개수(`countArea`)가 같은지를 확인하여 빙산이 여러 덩어리로 분리되었는지를 확인하였습니다.

빙산이 분리되면 반복문을 탈출하여 해당 시간을 출력하도록 하였습니다.  
얼음칸의 개수가 0개가 되면 얼음이 다 사라지기 전에 빙산이 분리되지 못한 것이므로 0을 출력하도록 하였습니다.

시간이 지날 때마다 melt함수에서 얼음 칸의 수를 갱신해주었는데, 기존의 board 함수를 변경하며 갱신하면 바다가 아니었던 칸이 바다가 되어 정확하지 않은 값이 반영될 수 있었습니다. 그래서 tmp 배열에 변경된 값들을 저장하고 전부 확인한 이후에 board값을 변경해주었습니다.


