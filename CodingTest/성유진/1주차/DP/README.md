## [가장 긴 감소하는 부분 수열](https://www.acmicpc.net/problem/11722)

원소 간의 폭은 고려하지 않고(연속하지 않아도 되고), 감소하는 수열 중 가장 긴 수열의 길이를 반환하는 문제


### 문제 풀이 방식


**1. 더 큰 수가 등장하면 갱신하여 dp 배열에 저장**

뒤에서부터 확인해서 더 큰 수가 등장하면 갱신하여 dp 배열에 저장합니다.

```
6
4 3 6 2 4 1
```
위와 같은 예시의 경우에 해당 방법으로는 
6 4 1을 가장 긴 감소 수열로 판단하여 3개를 정답으로 판별하지만,  
4 3 2 1 이 가장 긴 감소 수열이므로 4를 정답으로 판별합니다.


**2. 자신의 뒤에 있는 원소들을 모두 확인**

뒤에서부터 확인해서 더 큰 수가 등장하면 해당 위치에 횟수를 저장하고,   
자신의 뒤에 있는 원소들을 모두 확인해서 더 큰 횟수로 저장합니다.

다시 확인하여 보니 dp가 아닌 방식으로 푼 것 같네요..

## [퇴사2](https://www.acmicpc.net/problem/15486)
### 문제 풀이 방식
**1. 모두 탐색하는 방식**

가장 긴 감소하는 수열을 푼 방식과 동일하게 접근하여, 모두 탐색하는 방식으로 해결하려 하였으나 당연히,, 시간초과가 발생하였습니다.

**2. dp배열 활용한 방식**

풀이 방법이 잘 떠오르지 않아, 이전 풀이를 보고 해결하였습니다.  
result라는 변수에 가장 큰 수익을 저장하도록 하였습니다.  
상담을 뒤에서부터 확인하며 기간 내에 진행할 수 있는 상담이라면 기존의 result값과 현재 상담을 진행한 수익 중 더 큰 값으로 갱신하였습니다.  
기간 내에 상담이 불가능한 경우라면 기존의 가장 큰 값을 넣어주었습니다.

```java
for (int i = N; i > 0; i--) {
  if (i + T[i] <= N) { // 시간 내에 가능하면 갱신
    dp[i] = Math.max(dp[i], P[i] + dp[i + T[i]]);
  } 
}
```



## [평범한 배낭](https://www.acmicpc.net/problem/12865)

### 문제 풀이 방식
무게와 가치 두가지의 속성 중에 하나를 골라서 기준으로 결정하여 문제를 해결하려고 하였습니다.  
- 가치순 : 가치 높은 것부터
- 무게순 : 가벼운 것부터

둘 중 한 가지 방식으로 정렬을 하고, 정렬된 순서를 바탕으로 결과를 찾으려고 하였습니다.  
하지만 이런 방식으로는 찾을 수 없다는걸 깨달았지만 다른 해결 방안이 생각이 나지 않아서 블로그를 참조하여 해결하였습니다.

2차원 dp 배열을 생성하여 문제를 풀었습니다.
- i : 현재까지 확인한 아이템의 인덱스
- j : 배낭의 수용 가능 무게

`dp[i][j]의 의미 : i번째 아이템까지 확인한 경우에 j만큼의 무게까지 넣을 수 있는 경우에 최대로 가질 수 있는 가치`

j만큼의 무게를 수용가능한 가방에 현재 확인하는 i번째 아이템을 담을 수 있는 경우에는,  
가방에 현재 아이템을 넣지 않는 경우와 현재 아이템을 넣는 경우의 가치 크기를 비교하여 dp[i][j]의 값을 갱신합니다.

j만큼의 무게를 수용가능한 가방에 현재 확인하는 i번째 아이템을 담을 수 없는 경우에는,  
이전 아이템까지 확인한 경우의 가치 값을 그대로 넣어줍니다.

```java
for (int j = 1; j <= K; j++) {
  if (weight <= j) {
    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weight] + value);
  } else {
    dp[i][j] = dp[i-1][j];
  }
}
```

### 참고링크
https://chanhuiseok.github.io/posts/improve-6/
