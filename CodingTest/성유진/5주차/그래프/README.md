## [케빈 베이컨의 6단계 법칙](https://www.acmicpc.net/problem/1389)
### 문제 풀이 방식
dfs로 구현하면 한 명의 케빈 베이컨 수를 구하기 위해서 N-1번의 dfs를 수행해야 하기 때문에, 너무 비효율적일 듯하여 bfs로 구현하였습니다.

그리고 저번 그래프 문제들은 인접리스트로 구현하였는데, 이번 문제는 인접 행렬로 구현해보았습니다.  
N x N 크기의 link 배열을 만들어서 i, j 가 친구라면 `link[i][j] = true;` 로 저장하는 방식으로 구현하였습니다.  
두 노드가 연결되었는지 여부를 확인해야하기 때문에 리스트 내에 노드가 존재하는지 확인하는 것보다 인접행렬을 사용하여 인덱스로 확인하는 것이 더 적절하다고 생각하였습니다.


## [이분 그래프](https://www.acmicpc.net/problem/1707)
### 문제 풀이 방식
인접한 정점은 다른 집합에 속해야 하는 것이기 때문에 visited 배열에 속해 있는 집합의 번호를 0또는 1로 기록하였습니다.

bfs로 인접한 정점들을 방문하면서 방문하지 않았던 경우에는 현재 정점과 다른 집합번호로 설정해두고, 이미 방문한 경우에는 현재 정점의 집합 번호와 다른지 확인하였습니다. 만약 같다면 bfs를 종료하고 정답을 NO로 출력하였습니다.

그리고 문제에서 주어진 노드들의 연결되어있지 않은 경우를 고려해야한다는 것을 질문게시판에서 확인하고 해당 로직을 추가해주었습니다. `allVisited` 라는 함수를 만들어서 방문하지 않았던 정점 번호를 확인하여 반환해주도록 하였습니다. 모두 방문한 경우에는 탐색을 중단하고 YES를 출력하도록 하였습니다.
