## [수 찾기](https://www.acmicpc.net/problem/1920)
### 문제 풀이 방식
이미 정렬되어 있는 수열이어야 이분탐색이 가능하므로 입력받은 A 수열을 오름차순 정렬해주었습니다.
시작지점 인덱스인 `s`, 끝지점 인덱스인 `e`, 중간지점 인덱스인 `m`을 변수로 두어 활용하였습니다.
중간지점의 값을 찾으려는 값과 비교하여 탐색 범위를 절반으로 줄여 나갑니다.
```java
public static int binarySearch(int x) {
  int s = 0;
  int e = N - 1;
  while (s <= e) {
    int m = (s + e) / 2;
    if (A[m] == x) {
      return 1;
    } else if (A[m] < x) { // 찾으려는 값이 더 크므로 탐색 범위를 중간 지점 이후의 값들로 변경
      s = m + 1;
    } else if (A[m] > x) { // 찾으려는 값이 더 작으므로 탐색 범위를 중간 지점 이전의 값들로 변경
      e = m - 1;
    }
  }
  return 0;
}
```

## [나무 자르기](https://www.acmicpc.net/problem/2805)
### 문제 풀이 방식
이분탐색을 활용한 풀이 방식이 떠오르지 않아서 자르는 높이를 가장 큰 나무의 높이에서 1씩 줄여가면서 확인하여 잘린 길이를 확인하는 방식으로 구현해보았습니다. 당연히 시간 초과가 발생했습니다.

근데 도저히 모르겠어서 블로그를 참조하였습니다.  
https://st-lab.tistory.com/270 

**자르는 높이를 기준으로 이분탐색**
0에서 가장 높은 나무의 중간값에서부터 탐색을 시작하여 이 때 잘리는 높이가 얼마인지 확인하는 방식으로 구현한다고 합니다.

구현하는 것은 어렵지 않고 이전 문제에서 사용했던 이분 탐색 코드를 그대로 활용하였는데, 자꾸 틀렸습니다가 나오는 문제가 발생하였습니다..  
이진 탐색의 반환값을 무조건 m 즉, 중간 값으로 반환하도록 하여서 발생하는 문제였습니다.  
목표값과 정확하게 일치하는 경우에는 문제가 없지만, 그렇지 않은 경우에는 아래 예시와 같이 문제가 발생합니다.
```
3 5
3 3 3
```

위 처럼 입력이 들어오는 경우 반복문마다 변수의 값이 다음과 같습니다.
```
s e m curM | s e (조건문 지난 이후)
0 3 1  6   | 1 3
2 3 2  3   | 2 2
```
정답이 1이지만 반환값을 m으로 설정하면 2가 반환되는 문제가 발생하게 됩니다.
따라서 반환값을 m이 아닌 s + 1로 고쳐주었습니다.
