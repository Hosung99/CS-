# 나무 자르기
https://www.acmicpc.net/problem/2805

## 문제를 풀게 된흐름

## 주요 코드 설명
stack을 사용하였다.
각 숫자를 하나씩 처리하면서, 스택에 저장된 숫자보다 현재 숫자가 크면 스택에서 숫자를 pop하여 지우고, K번 지우기를 진행.
숫자를 지우는 과정에서 K번을 다 지우지 못했다면, 남은 숫자만큼 스택에서 pop한다.

```Java
    static void binarySearch(int bottom, int top) {
    if (bottom > top) {
        return ;
    }

    int mid = (bottom + top) / 2;
    long leftWood = calculateSliceTree(mid);
    if (!(leftWood < m))
        res = mid;
    if (leftWood == m) {
        return;
    }

    if (leftWood < m ) {
        binarySearch(bottom, mid - 1);
    } else {
        binarySearch(mid + 1, top);
    }
}

private static long calculateSliceTree(int sliceHigh) {
    long allLeftWood = 0L;
    for (int i = 0; i < numbers.length; i++) {
        long leftWood = numbers[i] - sliceHigh;
        if (leftWood >= 0) {
            allLeftWood += leftWood;
        }
    }
    return allLeftWood;
}
```
<br>

# 수찾기
https://www.acmicpc.net/problem/1920

## 문제를 풀게 된흐름

## 주요 코드 설명

```Java

    for (int i = 0; i < m; i++) {
        int isExist = binarySearch(0, numbers.length - 1, findNumbers[i]);
        bw.write(isExist + "\n");
        bw.flush();
    }
    

    private static int binarySearch(int start, int end, Long targetNum) {
    if (start > end) {
        return 0;
    }
    int mid = start + (end - start) / 2;
    if (numbers[mid].equals(targetNum)) {
        return 1;
    }

    if (numbers[mid] < targetNum) {
        return binarySearch(mid + 1, end, targetNum);
    } else {
        return binarySearch(start, mid - 1, targetNum);
    }
}
```