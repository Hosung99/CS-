# 가장 긴 감소하는 부분 수열
https://www.acmicpc.net/problem/11722
# 문제를 풀게 된 흐름
## 접근법
1. 문제 분석
   - 주어진 수열에서 가장 긴 부분감소수열의 크기를 구하라.
2. 알고리즘 선택
   - DP를 선택하였다.
   - DP를 선택한 이유 : 
     - DP 없이 한다면?
       - 우선 모든 부분수열을 직접 다 만들어 보는 방법이 있다. -> O(2^N) 시간 소요
         - O(2^N)인 이유
           ```모든 부분수열을 만들때 수열의 각 원소에 대해 포함할지 말지 두 가지 선택이 생깁니다.
           예를 들어) [10, 30, 20]이라면
           10을 포함할지 말지 결정
           30을 포함할지 말지 결정
           10을 포함할지 말지 결정
           이런식으로 N개의 원소에 대해 두가지씩 선택을 하게 돼요.
           각 원소에 대해 두가지 선택이 있으니까 2 * 2 * 2 ..(N번) = O(2^N) 이 된다```
       - 문제조건 `N : (1 ≤ N ≤ 1,000)`, `시간제한 1초` 이다.
       - 2^30만 되도 약 10억으로 10초가 걸리기 때문에 이 방법은 안된다. (1초 = 1억번)
     - DP를 사용한다면?
       - 현재까지 구한 부분감소수열을 매번 저장하여 연장 되는 부분감소수열을 구할 때 재활용한다. 설명이 어려우니 아래 구현방법과 코드를 함께 읽는게 좋다.
       - O(N^2)으로 시간복잡도가 개선된다. N이 최대 1000이므로 최악의 경우에도 1,000,000번만 연산을 하므로 시간제한을 만족할 수 있다.
3. 구현 전략
   - dp 배열에 부분감소수열의 길이들을 기록한다.
     - dp[i]에 sequence[0] ~ sequence[i] 까지의 부분감소수열 중 가장 긴값을 기록한다.
   - 모두 순회 후 가장 긴 값이 정답이다.