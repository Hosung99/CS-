## N과 M(12)

출력된 결과에서 중복된 숫자는 어차피 출력되므로 입력된 순열 중 중복 숫자는 의미가 없다고 판단.
따라서 중복이 존재하지 않는 Set 자료구조 중에서 정렬시켜주는 TreeSet을 이용해 입력 순열을 저장, 이를 정수형 배열로 변환

그리고 재귀를 통해서 출력할 수열의 인덱스를 정함.
처음엔 배열의 처음에 0 인덱스 저장.
다음 재귀에서는 바로 이전 인덱스 0과 같아도 상관 없으므로 이전 인덱스 부터 시작.

예를 들어 설명하자면,
만약 1 2 3 4 가 입력으로 들어왔다면
1. 0 0 0 0 이 될것이다.
2. 다음은 0 0 0 1
3. 0 0 0 2
4. 0 0 0 3
5. 0 0 1 1
6. 0 0 1 2
7. 0 0 1 3


이런식으로 인덱스만 answer 배열에 저장되고, 마지막 출력에는 해당 TreeSet으로 만들어진 Int 배열에서 인덱스로 값만 추출하면 끝!

## 알파벳

일반적인 DFS문제와 유사하나 평소의 visit배열을 사용하는 방법과 달리 이전에 나왔던 알파벳인지 아닌지가 중요하기 때문에
1차원 배열로 visited를 만들어서 사용하였다.

해당 배열은 알파벳의 아스키코드를 이용해서 인덱스로 사용하여 해당 알파벳이 등장한 적이 있는지 기록해 두었다.

그렇게 만들어진 visited 배열을 이용해 (0,0)좌표에서 재귀를 이용해 들어갈 수 있는 최대 길이를 측정해 주었다.

## 좋은 수열

30분정도 어떻게 해야할지 생각하다 도무지 생각나지않아 답을 보았다.
내 이론상 좋은 수열인지 하나하나 반복문으로 다 체크를 해야하는 방법은
뭔가 비효율적이라고 생각해서 그렇게 풀지 않았는데 해설을 보니 그게 답이었다.

좋은 수열인지만 확인하고 좋은수열일때만 재귀를 들어가는 방법으로 구현을 했다.
좋은 수열인지 판단하는 방법은 뒤에서 부터 첫번째 글자와 두번째 글자 비교,
뒤에서부터 처음 두글자와 다음 두글자 비교, 뒤에서부터 처음 세글자와 다음 세글자 비교,
이런식으로 인덱스를 하나하나 늘려가면서 같은지 비교하였다.

이렇게 좋은 수열인지만 검증된다면 다음 수를 작은 수 1 부터 넣어서 재귀를 돌린다.
이렇게만 하면 가장 작은 값의 좋은 수열을 찾을 수 있을 것이다.


## 가장 긴 감소하는 부분 수열

DP 너무 어려웠다.

현재 인덱스 이전까지의 감소수열 길이를 저장하고 있어야 할 것 같다 라는 생각까지는 했지만,
결국 풀지 못하고 답지를 봤다.

간단하게 풀이를 설명하자면 내 앞에 존재하는 나보다 큰 수들이 가지고 있는 수 중에 가장 큰 수보다 1큰 수를 들고 있으면 된다.
없다면 내가 가장 큰 수 이므로 초기값인 1을 가지게 된다.

아직 문제를 풀지 않은 사람이 이 풀이를 보고 이해를 할수 있을 지는 잘 모르겠다..
나의 DP 실력 이슈.. 조금더 실력을 갈고 닦고 다시 풀어볼 예정.
