## 조건
- r * c 의 사각형에서 갈 수 있는 최대의 거리를 구하라.
- 갈 수 있는 경로 : 현재 도착한 지점의 알파벳이 이전에 지나온 경로들의 알파벳에 포함되어 있으면 안된다.

## 접근법
- DFS를 사용하여 가능한 모든 경로를 탐색한다.
- 중복된 알파벳경로가 나오면 그 경로는 더 이상 진행하지 않고 다시 이전 기점으로 돌아온다.
- 매 경로를 밟을 때마다 현재 경로에서 이동한 거리와 maxDist의 값을 비교하여 더 큰것으로 갱신한다.

## 배운점
### 잘못된 시도
- BFS를 사용하려 했으나 BFS는 큐를 사용하는 원리이기 때문에 재귀(스택)로 구현하는 것은 자연스럽지 못하다.
  때문에 반복문을 사용해봤다. 그러나 문제가 발생하였다. DFS는 하나의 경로를 바닥까지 가기에 하나의 경로에 대한 알바벳 배열만 있으면 된다. 그러나 BFS는 모든 경로를 동시에 탐색하기 때문에 경로마다 알파벳배열이 각각 존재해야 한다.
  글이 이해가 안되면 아래 설명을 보자.
  - ex) 아래 예시에서 BFS를 사용한다고 예를 들어 본다. BFS는 3시방향을 시작으로 시계방향으로 돈다고 가정한다.\
  1. 처음 큐 : `{[0,0]}`
  2. `0,0` 방문, 현재 알파벳 배열 : `['I']`\
    a. `0,1` 큐에 삽입, 현재 큐 : `{[0,1]}`\
    b. `1,0` 큐에 삽입, 현재 큐 : `{[0,1], [1,0]}`\ 
  3. `0, 1` 방문, 현재 알파벳 배열 : `['I', 'F']`, 현재 큐 : `{[1,0]}`\
    a. `0,2` 큐에 삽입, 현재 큐 : `{[1,0], [0,2]}`\
    b. `1,1` 큐에 삽입, 현재 큐 : `{[1,0], [0,2], [1,1]}`\
  4. `1, 0` 방문, 현재 `F`알파벳위치인데 이는 사실 아직 갈 수 없는 경로가 아니다. 그러나 현재 알파벳 배열 : `['I', 'F']`라 `'F'`를 추가할 수가 없다. 이래서 각 경로마다 알파벳 배열을 새로 만들어줘야 하는것이다. \
    ```
    IFZCJ
    FHFKC
    FFALF
    HFGCF
    HMCHH
    ```
### 해결
- DFS를 사용하였다. DFS를 사용하면 알파벳 배열이 전역변수로 하나면 된다.