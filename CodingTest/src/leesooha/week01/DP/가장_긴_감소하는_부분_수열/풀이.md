## 접근법
- 처음 접근 방법 : 
  - 우선 모든 부분수열을 직접 다 만들어 보는 방법이 있다. -> O(2^N) 시간 소요
  - 문제조건 `N : (1 ≤ N ≤ 1,000)`, `시간제한 1초` 이다.
  - 2^30만 되도 약 10억으로 10초가 걸리기 때문에 이 방법은 안된다. (1초 = 1억번)
- 해결방법 : 
  - dp를 적용한다.
  - 현재까지 구한 부분감소수열을 매번 저장하여 연장 되는 부분감소수열을 구할 때 재활용한다. 설명이 어려우니 아래 구현방법과 코드를 함께 읽는게 좋다

## 구현방법
- dp 배열에 부분감소수열의 길이들을 기록한다.
  - dp[i]에 sequence[0] ~ sequence[i] 까지의 부분감소수열 중 가장 긴값을 기록한다.
- 모두 순회 후 가장 긴 값이 정답이다.