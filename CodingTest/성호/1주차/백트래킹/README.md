# 문제 1 N과 M(12)

## 문제 흐름

N개의 자연수 중에서 M개를 고른 수열을 모두 구하는 문제이다.

단, 중복되는 순열은 출력하면 안되며, 오름차순으로 출력해야 한다.

1. 오름차순으로 출력하기 위해 입력값을 정렬했다.
2. 중복되는 순열을 안만들기 위해 입력값의 중복을 제거했다.
3. 재귀함수를 통해 M개를 고르고 depth가 M이 되면 출력했다.

## 코드 설명

중복 제거를 위해 기존 배열을 set으로 변환하고 다시 배열로 전환했다.

```js
arr = [...new Set(arr)];
```

재귀함수를 돌릴 때, depth뿐만 아니라, index를 넘겨주어 중복되는 순열을 만들지 않도록 했다.

```js
function recursive(num, depth)
```

# 문제 2 알파벳

## 문제 흐름

R행 C열로 이루어진 보드에서, 각 칸에 알파벳이 적혀있다.

이동할 수 있는 방향은 상하좌우이며, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.

여기서 포인트는 같은 알파벳이 적힌 칸을 두 번 지날 수 없다는 것이다.

따라서, 방문한 알파벳을 체크하는 배열을 만들어서 방문한 알파벳을 체크했다.

알파벳을 방문할 때마다 방문한 알파벳을 체크하고, 재귀함수를 통해 상하좌우로 이동했다.

얼핏보면 Bfs로도 되지않을까? 생각했지만 bfs로는 안될 것 같았다. 방문한 알파벳을 체크하는것이 불가능할 것 같았다.

## 코드 설명

알파벳 26글자에 맞게 배열을 만들고, 방문한 알파벳을 체크했다.

```js
let visited = new Array(26).fill(false);
```

알파벳을 인덱스처럼 사용하기 위해 아스키 코드에 -65를 해주었다.

```js
let str = arr[nx][ny].charCodeAt() - 65;
```

방문을 안했다면 cnt를 1올리고 다음 x,y좌표로 이동해주었다.

```js
dfs(nx, ny, cnt + 1);
```

일반적으론 depth를 이용해 재귀함수의 끝을 판단하지만, 이 문제에선 배열의 nx, ny가 범위를 벗어나지 않는지 판단해 가지치기를 해주었다.

```js
if (nx < 0 || nx >= R || ny < 0 || ny >= C) {
	continue;
}
```

# 문제 3 좋은 수열

## 문제 흐름

길이가 N인 수열이 주어졌을 때, 다음 조건을 만족하는 수열을 구하는 문제이다.

사실 문제 이해까진했는데, 좋은수열을 판단하는 부분을 어떻게 구현해야할지 감이 안잡혀서 다른 사람의 코드를 참고했다.

## 코드 설명

depth를 이용해 1부터 3까지 문자열을 계속 붙여주는걸 재귀적으로 돌렸다.

```js
dfs(ans + "1", depth + 1);
dfs(ans + "2", depth + 1);
dfs(ans + "3", depth + 1);
```

이때 좋은 수열인지 판단을 해, 가지치기를 해주었다.

현재 str을 기준으로 새로 뽑은 마지막 문자를 제외하곤 좋은 수열인 상태이다.

그러므로 마지막 문자와 연관된 부분만 좋은 수열이 되는지 확인하면 된다.

substr로 나눠 비교해줄 두 부분의 문자열은 맨 마지막 문자를 포함한 i길이의 문자열과, 그 크기 만큼의 바로 앞 문자열을 비교하면 된다.

```js
function isValid(str) {
  let len = str.length;
  for (let i = 1; i <= Math.floor(len / 2); i++) {
    if (str.substr(len - i, i) === str.substr(len - i * 2, i)) {
      return false;
    }
  }
  return true;
}
```
