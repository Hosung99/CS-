# 문제 1 가장 긴 감소하는 부분 순열

## 문제 흐름

dp[i] = i번째 수를 마지막으로 하는 가장 긴 감소하는 부분 수열의 길이라고 생각했다.

풀고보니 그냥 2중 for문과 동일해진 느낌..

## 코드 설명

```js
if (arr[i - 1] < arr[j - 1] && dp[i] < dp[j] + 1) {
  dp[i] = dp[j] + 1;
}
```

# 문제 2 퇴사2

## 문제 흐름

dp[i] = i번째 날까지 일을 했을 때 최대 수익이라고 생각했다.

1부터 N까지 돌면서, i번째 날까지 일을 했을 때 최대 수익을 구했다.

여기서 포인트는 N일 까지 일을 했을 때 최대 수익을 구하는 것이다.

## 코드 설명

N일에도 일을 할 수 있으므로, N + 1일 까지 비교했다.

```js
if (i + arr[i][0] <= N + 1) {
  dp[i + arr[i][0]] = Math.max(dp[i + arr[i][0]], dp[i] + arr[i][1]);
}
```

# 문제 3 배낭

## 문제 흐름

배낭문제는 dp를 이용해 풀 수 있는 대표적인 문제이다.

dp[i][j] = i번째 물건까지 고려하고, j무게까지 담을 수 있을 때 최대 가치라고 생각했다.

## 코드 설명

이전 물건까지 고려했을 때, j무게까지 담을 수 있을 때 최대 가치를 구해야한다.

```js
for (let j = 1; j <= K; j++) {
  if (j - W >= 0) dp[i][j] = Math.max(dp[i - 1][j - W] + V, dp[i - 1][j]);
  else dp[i][j] = dp[i - 1][j];
}
```

다풀고나니 dp는 코드는 간단한데.. 메인로직이 어려운느낌