# 문제 1 수들의 합 2

## 문제 흐름

0.5초의 시간제한안에 input이 10,000이 들어왔다. O(N^2)의 시간복잡도로는 풀 수 없다.

따라서 부분수열의 합을 투포인터를 이용해 최적화하여 풀어야한다.

가장 바깥쪽 for문을 이용해 앞에서 부터 부분수열의 시작점을 구한다.

그 안에서 while을 이용해 조건을 가지고, 다른 포인터를 이동 시킨다.

제일 중요한 조건은 부분 수열의 합이 M보다 작은 경우에만 포인터를 이동시켜서 계산을 하는 것이다. M보다 커지면, 바로 탐색을 멈추어야한다.

## 코드 설명

```js
let idx = start;
while (sum < M && idx < N - 1) {
  idx++;
  sum += arr[idx];
}
```

# 문제 2 수 고르기

## 문제 흐름

2초의 시간제한안에 100,000의 input이 들어왔다. O(N^2)의 시간복잡도로는 풀 수 없다.

이 수열에서 2개를 뽑아서 제일 작은 경우를 구해야한다. 처음생각난건 dfs를 이용해 조합을 구하는건데.. 그러면 Input이 너무 커서 안될 것 같았다.

투포인터를 이용해 최적화를 해보려고했다.

그래서 정렬을하고 두개의 포인터를 적당히 이동시켜 값을 구했다.

처음 시도한건, start = 0, end = N - 1로해서 양끝에서 줄여가려고 했다.

근데 그렇게하니까, 모든 케이스를 찾을 수 없었다.. 그래서 start,end둘다 0으로 시작해서 두 수의 차이가 M보다 크다면 start를 이동시켜 차이를 줄였고, M보다 작다면 end를 이동시켜 차이를 늘렸다.

## 코드 설명

```js
while (end < N) {
  diff = arr[end] - arr[start];
  if (diff >= M) {
    ans = Math.min(ans, diff);
    start++;
  } else {
    end++;
  }
}
```

# 문제 3 같이 눈사람 만들래?

## 문제 흐름

이 문제를 풀다가 화가 났다. 너무 어렵게 생각했었다. 난 투포인터 개념을 정확히 이해하지 못했던 것 같다.

배열에서 4개의 아이템을 꺼내서 비교해야한다 nC4를 해야하는데.. 처음 접근한 방법은, start1,start2,end1,end2 4개의 포인터를 이용해 비교를 하려고 했다. 근데 로직이 너무 복잡해져서.. 포기하고 정답을 보았다.

되게 단순했다. 이중 for문으로 2개를 고르고 그안에서 투포인터를 이용해 2개를 고르는 방법이었다. 쩝.. 너무 어렵게 생각했다.. ㅠㅠ

## 코드 설명

```js
      let left = 0;
      let right = N - 1;
      while (left < right) {
        if (left === i || left === j) {
          left++;
          continue;
        }
        if (right === i || right === j) {
          right--;
          continue;
        }
        let sum = arr[left] + arr[right];
        ans = Math.min(Math.abs(height - sum), ans);
        if (height > sum) {
          left++;
        } else if (height < sum) {
          right--;
        } else {
          return 0;
        }
```
