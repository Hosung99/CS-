# 문제 1 오르막 수

## 문제 흐름

난 dp를 정말 못푸는 것 같다.. dp두 문제를 다 정답을 보고풀었다. ㅠㅠ

점화식 세우는 것도 어렵고, dp를 어떻게 적용해야할지 감이 안잡힌다... 공부 열심히하자..!

오르막수의 점화식은 다음과 같이 세울 수 있다.

```
	0 1 2 3 4 5 6 7 8 9 (끝 자리 수)
N 1 1 1 1 1 1 1 1 1 1 1 (자리수가 하나의 경우 오르막수는 한가지밖에 안된다.)
  2 1
  3 1
(자리수)
(끝자리가 0의 경우 항상 한개밖에 없다. ex 00, 000, 0000)
```

이렇게 1을 채워놓고, 2자리수의 1로 끝나는 수의 경우를 살펴보자.

```
	0 1 2 3 4 5 6 7 8 9 (끝 자리 수)
N 1 1 1 1 1 1 1 1 1 1 1 (자리수가 하나의 경우 오르막수는 한가지밖에 안된다.)
  2 1 2 3
  3 1
(자리수)
(끝자리가 0의 경우 항상 한개밖에 없다. ex 00, 000, 0000)
```

2자리수의 1로끝나는 오르막 수는 01, 11 밖에 없다.

2자리수의 2로끝나는 오르막 수는 02, 12, 22 밖에 없다.

이제 규칙이 보인다!

N자리수의 M으로 끝나는 오르막 수는 이전 오르막수와 N - 1 자리수의 M으로 끝나는 오르막수의 합이다! (왼쪽, 위의 합)

## 코드 설명

```js
for (let j = 0; j < 10; j++) {
  if (j === 0) {
    dp[i][j] = 1;
  } else {
    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    dp[i][j] %= 10007;
  }
}
```

# 문제 2 자두 나무

## 문제 흐름

퍼킹 Dp..

3차원 dp일 거 같은 느낌만 가졌는데, 구현이 너무 어려워서 답을 봤다.

dp[i][j][k] = [흐른시간][이동횟수][자두의 위치] 로 구현을 했다.

그래서 2중 for문으로 흐른시간과 해당 시간에 이동횟수별 메모이제이션을 했다.

## 코드 설명

```js

// 처음엔 항상1번나무에서 시작하므로 이전꺼에 1을 삼항연산자로 더해줬다.
if (j === 0) {
  dp[i][j][0] = dp[i - 1][j][0] + (arr[i] === 1 ? 1 : 0);
}

//[0]이 1번나무 [1]가 2번나무이다.
// 따라서 1번나무에 그대로 있거나, 옮겼을 때의 비교값으로 Max를 갱신해주었다.
else {
  dp[i][j][0] = Math.max(
    dp[i - 1][j][0] + (arr[i] === 1 ? 1 : 0),
    dp[i - 1][j - 1][1] + (arr[i] === 1 ? 1 : 0)
  );

  dp[i][j][1] = Math.max(
    dp[i - 1][j][1] + (arr[i] === 2 ? 1 : 0),
    dp[i - 1][j - 1][0] + (arr[i] === 2 ? 1 : 0)
  );
}
```
